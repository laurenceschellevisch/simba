(*
Pinball
=======

Stores all the routines to solve the Pinball random.  None of these routines
should be used throughout scripts.  They only need to be called in SRL's random
detection methods.

This solver uses findGapsTPA to determine which post to click.

*)

//{$DEFINE PB_DEBUG}

const
  PB_SCORE_10 = 180; // the tpa length of when the score is 10

(**
 * Author: Coh3n
 * Description: Detects if a player is in the Pinball random.
 *)
function PB_Detect(): boolean;
begin
  // makes sure friends tab exists and magic doesn't
  if ((not tabExists(TAB_MAGIC)) and (tabExists(TAB_FRIENDS))) then
    result := (Trim(GetTextAtExWrap(374, 238, 411, 253, 0, 5, 1,
        65535, 5, 'UpChars07')) = 'Score');
end;

(**
 * Author: Coh3n
 * Description: Returns the length of a tpa found of the yellow color of the
 * score at the top of the main screen.
 *)
function PB_GetScore(): integer;
var
  tpa: TPointArray;
begin
  // yellow color of the score
  if (findColorsTolerance(tpa, 65535, 373, 239, 434, 258, 30)) then
    result := length(tpa);
end;

(**
 * Author: SKy Scripter, NCDS, & Coh3n
 * Description: Returns true if a flashing pillar is found.  Sets coordinates
 * to x, y.
 *)
const
  _PB_FILL_COLOR = 10;
  _PB_MIN_LENGTH = 20;

function PB_ScanPost(var x, y: integer): boolean;
var
  tpa: TPointArray;
  pillarCols: array of integer;
  ATPA, pillarGaps: T2DPointArray;
  oldTarget, tmpCTS, bmp, i, j, c: integer;
  hue, sat, lum: extended;
  tmpBox: TBox;
begin
  result := false;
  bmp := -1;

  try
    tmpCTS := getColorToleranceSpeed;
    setColorToleranceSpeed(3);

    // the green of the spinning pillars
    findColorsTolerance(tpa, 6011467, MSX1, MMY1, MSX2, MSY2, 38);

    setColorToleranceSpeed(tmpCTS);

    // if colors aren't found, exit
    if (length(tpa) < _PB_MIN_LENGTH) then
      exit;

    bmp := createBitmap(MSX2 + 5, MSY2 + 5); // creats a bitmap of the MS
    fastDrawClear(bmp, _PB_FILL_COLOR); // fill it with a distinct color

    c := 0;
    pillarCols := getColors(tpa);

    // draws a rectangle on the bitmap of the colors that are light enough
    for i := 0 to high(tpa) do
    begin
      colorToHSL(pillarCols[i], hue, sat, lum);

      if (lum > 50.0) then
      begin
        tmpBox := intToBox(max(0, tpa[i].x - 1), max(0, tpa[i].y - 1), tpa[i].x + 1, tpa[i].y + 1);
        rectangleBitmap(bmp, tmpBox, clRed);
        inc(c);
      end;
    end;

    if (c > _PB_MIN_LENGTH) then
    begin
      floodFillBitmap(bmp, point(5, 5), _PB_FILL_COLOR, clBlack);

      oldTarget := getImageTarget();
      setTargetBitmap(bmp);

      findColors(tpa, _PB_FILL_COLOR, 0, 0, MSX2 - 5, MSY2 - 5);

      setImageTarget(oldTarget); // reset target to RS client

      if (length(tpa) > 10) then
      begin
        ATPA := TPAtoATPA(tpa, 60);
        sortATPASize(ATPA, true);

        for i := 0 to high(ATPA) do
        begin
          pillarGaps := findGapsTPA(ATPA[i], 10);

          for j := 0 to high(pillarGaps) do
            if (length(pillarGaps[j]) > 2) then
            begin
              middleTPAEx(ATPA[i], x, y);
              result := true;
              break;
            end;

          if (result) then
            break;
        end;
      end;
    end;

    {$IFDEF PB_DEBUG}
    displayDebugImgWindow(MSX2, MSY2);
    drawBitmapDebugImg(bmp);
    {$ENDIF}

  finally
    if (bmp <> -1) then
      freeBitmap(bmp);
  end;

  if (result) then
    addToSRLLog('PB_ScanPost: Found post');
end;

(**
 * Author: Coh3n
 * Description: Returns true if player clicks a post and the score changes.
 *)
function PB_TagPost(): boolean;
var
  t, x, y, oldScore: integer;
begin
  if (not loggedIn()) then
    exit;

  oldScore := PB_GetScore();

  if (PB_ScanPost(x, y)) then
  begin
    Mouse(x, y, 5, 5, mouse_right);

    if (WaitOptionMulti(['ag', 'g P'], 618)) then
    begin
      t := (getSystemTime + 6000);
      while (getSystemTime < t) do
      begin
        if (PB_GetScore() <> oldScore) then
        begin
          addToSRLLog('PB_TagPost: Tagged post');
          result := true;
          break;
        end;

        wait(300 + random(200));
      end;
    end else
      MMouse(x, y - 25, 8, 8);
  end;
end;

(**
 * Author: DemiseScythe & Coh3n
 * Description: Uses mainscreen walking to exit the random.
 * Updated: Fixed for 07scape. - DannyRS - 23/03/2013
 *)
function PB_Exit(): boolean;
var
  x, y, t, i: integer;
  tpa, tpa_Exit: TPointArray;
  ATPA: T2DPointArray;
  Deg: Extended;
begin

 if (not loggedIn()) then
   exit;
 addToSRLLog('PB_Exit: Exiting cave');
 SetAngle(SRL_ANGLE_HIGH);
 Deg := RS_GetCompassAngleDegrees;
 Wait(100 + random(50));
 MakeCompass('N');
 t := (getSystemTime + 25000);
 repeat
   // the green path color
   if (findColorsTolerance(tpa, 4544055, MSX1, MMCY+10, MSX2, MSY2, 35)) then
   begin
     if (length(tpa) > 0) then
     begin
       MiddleTPAEx(tpa, x, y);
       MMouse(x, y, 5, 5);
       Wait(RandomRange(90,150));
       if (waitUptextMulti(['Exit', 'xit', 'Cave', 'ave'], 200)) then
       begin
         ClickMouse2(mouse_left);
         if (waitTabExists(TAB_MAGIC, 8000)) then
         begin
           result := true;
           break;
         end;
       end;
     end;
   end;
   if (findColorsTolerance(tpa, 5734757, MSX1, MMCY, MSX2, MSY2, 35)) then
     if (length(tpa) > 0) then
     begin
       sortTPAFrom(tpa, point(MSCX, MSY2)); // center of the bottom of the MS
       x := tpa[0].x;
       y := tpa[0].y - 20; // so it's actually on the MS

       MMouse(x, y, 5, 5);

       // check for the proper uptexts
       if (waitUptextMulti(['Walk', 'alk', 'here', 'ere'], 200)) then
       begin
         ClickMouse2(mouse_left);
       end
       else if (waitUptextMulti(['Exit', 'xit', 'Cave', 'ave'], 200)) then
       begin
         ClickMouse2(mouse_left);
         if (waitTabExists(TAB_MAGIC, 8000)) then
         begin
           result := true;
           break;
         end;
       end;
     end;
   result := tabExists(TAB_MAGIC); // just in case
   wait(2000 + random(300));
 until ((getSystemTime > t) or (result));
 if (result) then
 begin
   Wait(100 + random(500));
   MakeCompass(Deg);
   addToSRLLog('PB_Exit: Clicked exit cave')
 end else
 begin
   addToSRLLog('PB_Exit: Took to long to find exit... Looking for backup');
   t := (getSystemTime + 20000);
   MakeCompass('S');
   repeat
     if (FindColorsTolerance(tpa_Exit, 4677175, MSX1, MSY1, MSX2, MSY2, 23)) then
       ATPA := TPAToATPAEx(tpa_Exit, 70, 5);
     if (length(ATPA) > 0) then
     begin
       SortATPASize(ATPA, True);
       for i := 0 to High(ATPA) do
       begin
         MiddleTPAEx(ATPA[i], x, y);
         MMouse(x, y, 5, 5);
         Wait(RandomRange(90,150));
         if (waitUptextMulti(['Exit', 'xit', 'Cave', 'ave'], 200)) then
         begin
           ClickMouse2(mouse_left);
           if (waitTabExists(TAB_MAGIC, 8000)) then
           begin
             result := true;
             break;
           end;
         end;
       end;
     end;
     result := tabExists(TAB_MAGIC);
     wait(2000 + random(300));
   until ((getSystemTime > t) or (result));
   if (result) then
     addToSRLLog('PB_Exit: Clicked exit cave with backup')
   else
     addToSRLLog('PB_Exit: Failed to exit')
 end;
end;

(**
 * Author: Coh3n & DemiseScythe
 * Description: Solves the Pinball random.
 *)
function PB_Solve(): boolean;
var
  t: integer;
begin
  if (not loggedIn()) then
    exit;

  t := (getSystemTime + (15 * 60000)); // maximum 15 minutes
  doConversation('', false);

  repeat
    if (PB_GetScore = PB_SCORE_10) then // length of "Score: 10"
    begin
      if (PB_Exit()) then
      begin
        result := true;
        break;
      end;
    end else
      PB_TagPost();

    wait(500 + random(200));
  until(result or (getSystemTime > t));
end;
